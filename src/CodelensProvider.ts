import axios from 'axios';
import * as vscode from 'vscode';


interface ChatGPTResponse {
	choices: {
		text: string;
	}[];
  }
/**
 * CodelensProvider
 */
export class CodelensProvider implements vscode.CodeLensProvider {

	private codeLenses: vscode.CodeLens[] = [];
	private regex: RegExp;
	private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>();
	public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event;

	constructor() {
		this.regex =  /(class\s+(\w+)\s*(?::\s*(?:public|private|protected)\s+(\w+)\s*)*(?:\{|$))|(\w+\s+\w+\s*\([^)]*\)\s*(?:const)?\s*(?={))/g;
		/*/(.+)/g;*/

		vscode.workspace.onDidChangeConfiguration((_) => {
			this._onDidChangeCodeLenses.fire();
		});
	}

	public async provideCodeLenses(document: vscode.TextDocument, token: vscode.CancellationToken): Promise<vscode.CodeLens[]> {
		if (vscode.workspace.getConfiguration("codelens-sample").get("enableCodeLens", true)) {
			this.codeLenses = [];
			const regex = new RegExp(this.regex);
			const text = document.getText();
			let matches;
			while ((matches = regex.exec(text)) !== null) {
			const line = document.lineAt(document.positionAt(matches.index).line);
			const indexOf = line.text.indexOf(matches[0]);
			const position = new vscode.Position(line.lineNumber, indexOf);
			const range = document.getWordRangeAtPosition(position, new RegExp(this.regex));
			if (range) {
				const summary = await this.generateSummary(matches[0]);
				const codeLens = new vscode.CodeLens(range, {
					title: summary,
					tooltip: "Summary generated by ChatGPT",
					command: ""
				});
				this.codeLenses.push(codeLens);
			}
			}
			return this.codeLenses;
		}
		return [];
		}

	public resolveCodeLens(codeLens: vscode.CodeLens, token: vscode.CancellationToken) {
		if (vscode.workspace.getConfiguration("codelens-sample").get("enableCodeLens", true)) {
			codeLens.command = {
				title: "Codelens provided by sample extension",
				tooltip: "Tooltip provided by sample extension",
				command: "codelens-sample.codelensAction",
				arguments: ["Argument 1", false]
			};
			return codeLens;
		}
		return null;
	}

	private async generateSummary(code: string): Promise<string> {
		const apiKey = process.env.OPENAI_API_KEY; 
		const response = await axios.post<ChatGPTResponse>('https://api.openai.com/v1/engines/davinci-codex/completions', {
			prompt: `summarize code: ${code}`,
			max_tokens: 64,
			n: 1,
			stop: ['\n'],
		}, {
			headers: {
			'Content-Type': 'application/json',
			'Authorization': `Bearer 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`,
			},
		});
		return response.data.choices[0].text.trim();
		}
}
