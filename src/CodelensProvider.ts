import * as vscode from 'vscode';
import { OpenAIApi, Configuration } from "openai";



// OpenAIApi required config
const configuration = new Configuration({
	apiKey: process.env.OPENAI_API_KEY,
  });

  // OpenAIApi initialization
const openai = new OpenAIApi(configuration);

/**
 * CodelensProvider
 */
export class CodelensProvider implements vscode.CodeLensProvider {

	private codeLenses: vscode.CodeLens[] = [];
	private regex: RegExp;
	private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>();
	public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event;

	constructor() {
		
		
		//find all functions and classes
		//this.regex=/(class\s+(\w+)\s*(?::\s*(?:public|private|protected)\s+(\w+)\s*)*(?:\{|$))|(\w+\s+\w+\s*\([^)]*\)\s*(?:const)?\s*(?={))/g;
		

		// all function: this.regex = (\w+\s+\w+\(\))\s*\{((?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*)\}/g;

		//all classes
		this.regex =  /class\s+\w+\s*\{(?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*\}/g;

		//all file
		//this.regex = /(#include\s)+.+[\s\S]*/g;



		
					

		vscode.workspace.onDidChangeConfiguration((_) => {
			this._onDidChangeCodeLenses.fire();
		});
	}

	public async provideCodeLenses(document: vscode.TextDocument, token: vscode.CancellationToken): Promise<vscode.CodeLens[]> {
		if (vscode.workspace.getConfiguration("codelens-sample").get("enableCodeLens", true)) {
			this.codeLenses = [];


			const regex = new RegExp(this.regex);
			const text = document.getText();
			let matches;
			

			
			while ((matches = regex.exec(text)) !== null) {
				const { line, character } = document.positionAt(matches.index);
				const position = new vscode.Position(line, character);
				const range = document.getWordRangeAtPosition(position, /\S+/);
			
			
				if (range) {
					const codeLens = new vscode.CodeLens(range, {
						title: "show summary",
						tooltip: "Summary generated by ChatGPT",
						command: "codelens-sample.showSummary",
						arguments: [matches[0]]
					});
					this.codeLenses.push(codeLens);
				}
				}
			return this.codeLenses;
		}
		return [];
		}
    

	/*public resolveCodeLens(codeLens: vscode.CodeLens, token: vscode.CancellationToken) {
		if (vscode.workspace.getConfiguration("codelens-sample").get("enableCodeLens", true)) {
			codeLens.command = {
				title: "Codelens provided by sample extension",
				tooltip: "Tooltip provided by sample extension",
				command: "codelens-sample.showSummary",
				arguments: [this.generateSummary("Argument 1")]
			};
			return codeLens;
		}
		return null;
	}*/


	}
		
	// Register command handler for the CodeLens command
	vscode.commands.registerCommand("codelens-sample.showSummary", async (payload: string) => {
		
		const summary = await generateSummary(payload);
		//vscode.window.showInformationMessage(summary);
		const panel = vscode.window.createWebviewPanel(
			"summaryPanel",
			"Summary",
			vscode.ViewColumn.Two,
			{}
		);
		panel.webview.html = summary;
		
	});


	async function generateSummary(code: string): Promise<string> {
		try {
			let prompt = `Summarize: ${code}`;
			const completions = await openai.createCompletion({
				model: 'text-davinci-003',
				prompt: prompt,
				temperature: 0.1,
				max_tokens: 400,
				n: 1,
			});
			const summary = completions.data.choices[0].text!.trim();
			
			prompt = `${code}`;
			const instruction = "clean up and refactor";
			const edits = await openai.createEdit({
				model: 'code-davinci-edit-001',
				input: prompt,
				instruction: instruction,
				temperature: 0.7,
				n: 1,
			});
			const editation = edits.data.choices[0].text!.trim();
			return `Input/Code:<br>${code}
			<br><br>
			Completion:<br>${summary} 
			<br><br> 
			Edit:<br>${editation}`;



		} catch (error) {
			console.error(`OpenAI API error: ${error}`);
			throw new Error(`Failed to generate summary: ${error}`);
		}
	}
	
	