import * as vscode from 'vscode';
import { OpenAIApi, Configuration } from "openai";
import * as hljs from 'highlight.js';



// OpenAIApi required config
const configuration = new Configuration({
	apiKey: process.env.OPENAI_API_KEY,
  });

  // OpenAIApi initialization
const openai = new OpenAIApi(configuration);

/**
 * CodelensProvider
 */
export class CodelensProvider implements vscode.CodeLensProvider {

	private codeLenses: vscode.CodeLens[] = [];
	private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>();
	public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event;

	constructor() {
		
		
		//find all functions and classes
		//this.regex=/(class\s+(\w+)\s*(?::\s*(?:public|private|protected)\s+(\w+)\s*)*(?:\{|$))|(\w+\s+\w+\s*\([^)]*\)\s*(?:const)?\s*(?={))/g;
		
		// all function: this.regex = (\w+\s+\w+\(\))\s*\{((?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*)\}/g;

		//all classes
		//this.regex =  /class\s+\w+\s*\{(?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*\}/g;

		//all file
		//this.regex = /(#include\s)+.+[\s\S]*/g;

		vscode.workspace.onDidChangeConfiguration((_) => {
			this._onDidChangeCodeLenses.fire();
		});
	}

	public async provideCodeLenses(document: vscode.TextDocument, token: vscode.CancellationToken): Promise<vscode.CodeLens[]> {
		if (vscode.workspace.getConfiguration("codelens-sample").get("enableCodeLens", true)) {
			this.codeLenses = [];


			//const regex = new RegExp(this.regex);

			const regexes = [
				/class\s+\w+\s*\{(?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*\}/g,
				/(#include\s)+.+[\s\S]*/g
			];
			
			const text = document.getText();
			let matches;
			for (const regex of regexes) {
				while ((matches = regex.exec(text)) !== null) {
					const { line, character } = document.positionAt(matches.index);
					const position = new vscode.Position(line, character);
					const range = document.getWordRangeAtPosition(position, /\S+/);
			
					if (range) {
						const codeLens = new vscode.CodeLens(range, {
							title: "show summary",
							tooltip: "Summary generated by ChatGPT",
							command: "codelens-sample.showSummary",
							arguments: [matches[0]]
						});
						this.codeLenses.push(codeLens);
					}
				}
			}
			return this.codeLenses;
		}

		return [];
		}
    

	}
	
		// Register command handler for the CodeLens command
	vscode.commands.registerCommand("codelens-sample.showSummary", async (payload: string) => {
		
		const summary = await generateSummary(payload);
		const panel = vscode.window.createWebviewPanel(
			"summaryPanel",
			"Summary",
			vscode.ViewColumn.Two,
			{
				// Enable scripts in the webview
				enableScripts: true
			}
		);

    // Set the HTML content and CSS style for the webview panel
    panel.webview.html = `
    <!DOCTYPE html>
    <html>
        <head>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    font-size: 12px;
                    line-height: 1.2;
                    padding: 20px;
                }

                h1 {
                    font-size: 24px;
                    margin-bottom: 10px;
                }

                p {
                    margin-bottom: 10px;
                }

                pre {
					padding: 10px;
                    background-color: #f5f5f5;
                    border-radius: 5px;
                    overflow-x: auto;
					word-wrap: break-word;
                }

                .hljs {
                    color: #333;
                    tab-size: 4;
                }
            </style>
            <link href="https://cdn.jsdelivr.net/npm/highlight.js@11.3.1/styles/default.min.css" rel="stylesheet">
        </head>
        <body>
            <h1>Summary</h1>
            <pre><code class="hljs cpp">${(hljs as any).highlightAuto( summary).value}</code></pre>
        </body>
    </html>
    `;
	});
		


	async function generateSummary(code: string): Promise<string> {
		try {
			let prompt = `Summarize the code: ${code}`;
			let completions = await openai.createCompletion({
				model: 'text-davinci-003',
				prompt: prompt,
				temperature: 0.7,
				max_tokens: 1000,
				n: 1,
			});
			const summary = completions.data.choices[0].text!.trim();

			prompt = `formulate the high level requirements for this code: ${code}`;
		
			completions = await openai.createCompletion({
				model: 'text-davinci-003',
				prompt: prompt,
				temperature: 0.3,
				max_tokens: 1000,
				n: 1,
			});
			const summary2 = completions.data.choices[0].text!.trim();

			prompt = `describe the idea behind the code: ${code}`;		
			completions = await openai.createCompletion({
				model: 'text-davinci-003',
				prompt: prompt,
				temperature: 0.3,
				max_tokens: 1000,
				n: 1,
			});
			const summary3 = completions.data.choices[0].text!.trim();

			prompt = `${code}`;		
			const editorial = await openai.createEdit({
				model: 'code-davinci-edit-001',
				input: prompt,
				instruction: 'improve the class and add comments',
				temperature: 0.59
			});
			const edit = editorial.data.choices[0].text!.trim();

			return `\n1: Summary\n/*${breaklines(summary)} */\n\n2: Requirements\n${breaklines(summary2)}\n\n3: Idea\n${breaklines(summary3)}\n\nRefactoring:\n\n${edit}\n\n\nOriginal Code:\n\n${code}\n`;

		} catch (error) {
			console.error(`OpenAI API error: ${error}`);
			throw new Error(`Failed to generate summary: ${error}`);
		}

		function breaklines(summary: string) {
			const wordsPerLine = 10; // Change this to the desired number of words per line
			const words = summary.split(' ');
			for (let i = wordsPerLine; i < words.length; i += wordsPerLine + 1) {
				words.splice(i, 0, '\n');
			}
			const summaryWithLineBreaks = words.join(' ');
			return summaryWithLineBreaks;
		}
	}
	
	